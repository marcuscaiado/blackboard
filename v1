<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Blackboard App</title>
    <style>
        :root {
            --bg-color: #000000;
            --panel-bg: rgba(20, 20, 20, 0.9);
            --border-color: #333;
            --text-color: #ccc;
            --accent-red: #ff3333;
        }

        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none; /* Prevents scrolling on mobile */
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }

        /* UI Overlay */
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none; /* Let clicks pass through to canvas where simpler */
            max-height: 95vh;
        }

        h1 {
            color: var(--accent-red);
            font-size: 2rem;
            margin: 0;
            font-weight: 800;
            letter-spacing: -1px;
            text-shadow: 0 2px 10px rgba(255, 0, 0, 0.2);
            pointer-events: auto;
            padding-left: 10px;
        }

        .panel {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 260px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .section-title {
            color: #666;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        /* Tool Buttons */
        .btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        button {
            background: #2a2a2a;
            border: 1px solid #333;
            color: var(--text-color);
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        button:hover { background: #3a3a3a; }
        button:active { transform: scale(0.96); }
        
        button.active {
            background: #444;
            border-color: #666;
            color: #fff;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        button.btn-magic.active { background: #6b21a8; border-color: #9333ea; }
        button.btn-delete:hover { background: #451a1a; color: #ff6666; border-color: #662222; }

        /* Sliders */
        input[type="range"] {
            width: 100%;
            background: transparent;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            background: #333;
            height: 4px;
            border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            background: #888;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-top: -6px;
            cursor: pointer;
        }

        /* File Actions */
        .file-actions {
            display: flex;
            gap: 8px;
        }
        .file-btn { flex: 1; font-size: 0.8rem; }
        .btn-export { background: #1e40af; border-color: #1e3a8a; color: white; width: 100%; margin-top: 5px;}
        .btn-export:hover { background: #2563eb; }

        /* Hidden Input */
        #file-input { display: none; }

        /* Toast Notification */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>

    <div id="ui-container">
        <h1>BLACKBOARD</h1>

        <div class="panel">
            <!-- Tools -->
            <div>
                <div class="section-title">Tools</div>
                <div class="btn-grid">
                    <button id="tool-magic" class="active btn-magic">‚ú® Magic</button>
                    <button id="tool-chalk">‚úèÔ∏è Chalk</button>
                    <button id="tool-eraser">üßπ Eraser</button>
                    <button id="action-clear" class="btn-delete">üóëÔ∏è Clear</button>
                </div>
            </div>

            <!-- Size -->
            <div>
                <div class="section-title">Size <span id="size-display">6px</span></div>
                <input type="range" id="size-slider" min="2" max="40" value="6">
            </div>

            <hr style="border: 0; border-top: 1px solid #333; width: 100%; margin: 5px 0;">

            <!-- History -->
            <div class="btn-grid">
                <button id="action-undo">‚Ü©Ô∏è Undo</button>
                <button id="action-redo">‚Ü™Ô∏è Redo</button>
            </div>

            <!-- Save/Load -->
            <div>
                <button id="action-export" class="btn-export">üì∑ Export Image</button>
                <div class="file-actions" style="margin-top: 8px;">
                    <button id="action-save" class="file-btn">üíæ Save</button>
                    <button id="action-load" class="file-btn">üìÇ Load</button>
                </div>
                <input type="file" id="file-input" accept=".json">
            </div>
        </div>
    </div>

    <div id="toast">Notification</div>

    <script>
        /**
         * BLACKBOARD APP LOGIC
         * - Canvas rendering
         * - Shape recognition geometry engine
         * - State management
         */

        // --- Configuration ---
        const CONFIG = {
            bgColor: '#000000'
        };

        // --- State ---
        const state = {
            strokes: [],
            history: [],
            redoStack: [],
            currentTool: 'magic', // magic, chalk, eraser
            currentColor: '#FFFFFF',
            brushSize: 6,
            isDrawing: false,
            currentStroke: null
        };

        // --- DOM Elements ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on bg
        const sizeSlider = document.getElementById('size-slider');
        const sizeDisplay = document.getElementById('size-display');
        const fileInput = document.getElementById('file-input');
        const toastEl = document.getElementById('toast');

        // --- Initialization ---
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            setupTools();
            setupActions();
            setupPointerEvents();
            requestAnimationFrame(renderLoop);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            render(); // Force re-render immediately
        }

        function setupTools() {
            document.getElementById('tool-magic').onclick = () => setTool('magic');
            document.getElementById('tool-chalk').onclick = () => setTool('chalk');
            document.getElementById('tool-eraser').onclick = () => setTool('eraser');
            
            sizeSlider.oninput = (e) => {
                state.brushSize = parseInt(e.target.value);
                sizeDisplay.innerText = state.brushSize + 'px';
            };
        }

        function setupActions() {
            document.getElementById('action-undo').onclick = undo;
            document.getElementById('action-redo').onclick = redo;
            document.getElementById('action-clear').onclick = clearBoard;
            document.getElementById('action-save').onclick = saveToFile;
            document.getElementById('action-load').onclick = () => fileInput.click();
            document.getElementById('action-export').onclick = exportImage;
            
            fileInput.onchange = loadFromFile;
        }

        function setTool(tool) {
            state.currentTool = tool;
            updateUI();
        }

        function updateUI() {
            // Update active buttons
            ['magic', 'chalk', 'eraser'].forEach(t => {
                const btn = document.getElementById(`tool-${t}`);
                if (state.currentTool === t) btn.classList.add('active');
                else btn.classList.remove('active');
            });
        }
        
        // --- Geometry Engine (The "Magic" Part) ---

        const distance = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

        const getPathLength = (points) => {
            let len = 0;
            for (let i = 1; i < points.length; i++) len += distance(points[i-1], points[i]);
            return len;
        };

        const resample = (points, targetCount = 40) => {
            if (points.length < 2) return points;
            const totalLen = getPathLength(points);
            const step = totalLen / (targetCount - 1);
            const newPoints = [points[0]];
            let D = 0;
            let currentIdx = 1;
            let lastPoint = points[0];

            while (currentIdx < points.length) {
                const p2 = points[currentIdx];
                const d = distance(lastPoint, p2);
                if (D + d >= step) {
                    const ratio = (step - D) / d;
                    const nx = lastPoint.x + ratio * (p2.x - lastPoint.x);
                    const ny = lastPoint.y + ratio * (p2.y - lastPoint.y);
                    const np = {x: nx, y: ny};
                    newPoints.push(np);
                    lastPoint = np;
                    D = 0;
                } else {
                    D += d;
                    lastPoint = p2;
                    currentIdx++;
                }
            }
            if (newPoints.length < targetCount) newPoints.push(points[points.length - 1]);
            return newPoints;
        };

        const createPerfectShape = (type, points) => {
            const xs = points.map(p => p.x);
            const ys = points.map(p => p.y);
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            const width = maxX - minX;
            const height = maxY - minY;
            const centerX = minX + width / 2;
            const centerY = minY + height / 2;

            if (type === 'circle') {
                const radius = Math.max(width, height) / 2;
                const circlePoints = [];
                for (let i = 0; i <= 60; i++) {
                    const angle = (i / 60) * Math.PI * 2;
                    circlePoints.push({
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY + Math.sin(angle) * radius
                    });
                }
                return circlePoints;
            }
            if (type === 'rectangle') {
                return [
                    { x: minX, y: minY }, { x: maxX, y: minY },
                    { x: maxX, y: maxY }, { x: minX, y: maxY },
                    { x: minX, y: minY }
                ];
            }
            if (type === 'triangle') {
                return [
                    { x: centerX, y: minY }, { x: maxX, y: maxY },
                    { x: minX, y: maxY }, { x: centerX, y: minY }
                ];
            }
            if (type === 'line') {
                return [points[0], points[points.length - 1]];
            }
            return points;
        };

        const smoothStroke = (points) => {
            if (points.length < 3) return points;
            const smoothed = [points[0]];
            for (let i = 1; i < points.length - 1; i++) {
                smoothed.push({
                    x: (points[i - 1].x + points[i].x + points[i + 1].x) / 3,
                    y: (points[i - 1].y + points[i].y + points[i + 1].y) / 3,
                });
            }
            smoothed.push(points[points.length - 1]);
            return smoothed;
        };

        const recognizeShape = (originalPoints) => {
            if (originalPoints.length < 5) return { type: 'freehand', points: smoothStroke(originalPoints) };
            
            const points = resample(originalPoints, 40);
            const len = getPathLength(points);
            const distStartEnd = distance(points[0], points[points.length - 1]);
            const isClosed = distStartEnd < len * 0.20;

            // 1. Line Check
            if (!isClosed) {
                const p1 = points[0];
                const p2 = points[points.length - 1];
                let maxDeviation = 0;
                const a = p1.y - p2.y;
                const b = p2.x - p1.x;
                const c = p1.x * p2.y - p2.x * p1.y;
                const denom = Math.sqrt(a*a + b*b);
                if (denom > 0) {
                    for (const p of points) {
                        const dist = Math.abs(a * p.x + b * p.y + c) / denom;
                        if (dist > maxDeviation) maxDeviation = dist;
                    }
                }
                if (maxDeviation < len * 0.05) return { type: 'line', points: createPerfectShape('line', originalPoints) };
                return { type: 'freehand', points: smoothStroke(originalPoints) };
            }

            // 2. Circle Check
            let cx = 0, cy = 0;
            points.forEach(p => { cx += p.x; cy += p.y; });
            cx /= points.length;
            cy /= points.length;
            let meanRadius = 0;
            points.forEach(p => meanRadius += distance(p, {x: cx, y: cy}));
            meanRadius /= points.length;
            let variance = 0;
            points.forEach(p => variance += Math.pow(distance(p, {x: cx, y: cy}) - meanRadius, 2));
            variance /= points.length;
            
            if (Math.sqrt(variance) / meanRadius < 0.18) return { type: 'circle', points: createPerfectShape('circle', originalPoints) };

            // 3. Rect/Triangle Check
            const xs = points.map(p => p.x);
            const ys = points.map(p => p.y);
            const width = Math.max(...xs) - Math.min(...xs);
            const height = Math.max(...ys) - Math.min(...ys);
            const bboxArea = width * height;
            let area = 0;
            for(let i=0; i<points.length-1; i++) {
                area += points[i].x * points[i+1].y - points[i+1].x * points[i].y;
            }
            area = Math.abs(area / 2);
            const fillRatio = area / bboxArea;

            if (fillRatio > 0.75) return { type: 'rectangle', points: createPerfectShape('rectangle', originalPoints) };
            if (fillRatio > 0.35 && fillRatio < 0.65) return { type: 'triangle', points: createPerfectShape('triangle', originalPoints) };

            return { type: 'freehand', points: smoothStroke(originalPoints) };
        };


        // --- Drawing Logic ---

        function setupPointerEvents() {
            canvas.addEventListener('pointerdown', e => {
                e.target.setPointerCapture(e.pointerId);
                state.isDrawing = true;
                const point = { x: e.clientX, y: e.clientY };
                state.currentStroke = {
                    points: [point],
                    color: state.currentColor,
                    size: state.currentTool === 'eraser' ? 40 : state.brushSize,
                    tool: state.currentTool,
                    shapeType: null
                };
            });

            canvas.addEventListener('pointermove', e => {
                if (!state.isDrawing || !state.currentStroke) return;
                state.currentStroke.points.push({ x: e.clientX, y: e.clientY });
            });

            const endStroke = (e) => {
                if (!state.isDrawing || !state.currentStroke) return;
                state.isDrawing = false;
                e.target.releasePointerCapture(e.pointerId);

                let finalStroke = state.currentStroke;

                // Apply Magic
                if (state.currentTool === 'magic') {
                    const result = recognizeShape(finalStroke.points);
                    finalStroke.points = result.points;
                    finalStroke.shapeType = result.type;
                } else if (state.currentTool === 'chalk') {
                     // Basic smoothing for raw chalk too, just a tiny bit? No, raw is raw.
                }

                saveToHistory();
                state.strokes.push(finalStroke);
                state.redoStack = []; // Clear redo on new action
                state.currentStroke = null;
                render();
            };

            canvas.addEventListener('pointerup', endStroke);
            canvas.addEventListener('pointerleave', endStroke);
        }

        function saveToHistory() {
            // Deep copy strokes
            state.history.push(JSON.parse(JSON.stringify(state.strokes)));
            // Limit history size if needed
            if (state.history.length > 50) state.history.shift();
        }

        // --- Rendering ---

        function renderLoop() {
            if (state.isDrawing) render();
            requestAnimationFrame(renderLoop);
        }

        function render() {
            // Clear Background
            ctx.fillStyle = CONFIG.bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Saved Strokes
            state.strokes.forEach(stroke => drawStroke(stroke));

            // Draw Current Stroke
            if (state.currentStroke) {
                drawStroke(state.currentStroke);
            }
        }

        function drawStroke(stroke) {
            if (stroke.points.length < 1) return;

            ctx.beginPath();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = stroke.size;

            if (stroke.tool === 'eraser') {
                ctx.strokeStyle = CONFIG.bgColor;
                ctx.shadowBlur = 0;
            } else {
                ctx.strokeStyle = stroke.color;
                ctx.shadowBlur = 1;
                ctx.shadowColor = stroke.color;
            }

            const p = stroke.points;
            ctx.moveTo(p[0].x, p[0].y);

            // Use straight lines for geometric shapes, curves for freehand
            if (stroke.shapeType && stroke.shapeType !== 'freehand') {
                for (let i = 1; i < p.length; i++) ctx.lineTo(p[i].x, p[i].y);
            } else {
                if (p.length === 1) ctx.lineTo(p[0].x, p[0].y);
                else {
                    // Quadratic curve smoothing for display
                    for (let i = 1; i < p.length - 1; i++) {
                        const midX = (p[i].x + p[i + 1].x) / 2;
                        const midY = (p[i].y + p[i + 1].y) / 2;
                        ctx.quadraticCurveTo(p[i].x, p[i].y, midX, midY);
                    }
                    ctx.lineTo(p[p.length - 1].x, p[p.length - 1].y);
                }
            }
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        // --- File Operations & Undo/Redo ---

        function undo() {
            if (state.history.length === 0) return showToast("Nothing to undo");
            state.redoStack.push(JSON.parse(JSON.stringify(state.strokes)));
            state.strokes = state.history.pop();
            render();
        }

        function redo() {
            if (state.redoStack.length === 0) return showToast("Nothing to redo");
            saveToHistory();
            state.strokes = state.redoStack.pop();
            render();
        }

        function clearBoard() {
            if (confirm("Clear the entire board?")) {
                saveToHistory();
                state.strokes = [];
                state.redoStack = [];
                render();
            }
        }

        function saveToFile() {
            const data = JSON.stringify(state.strokes);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `blackboard-${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            showToast("Saved!");
        }

        function loadFromFile(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const loaded = JSON.parse(event.target.result);
                    if (Array.isArray(loaded)) {
                        saveToHistory();
                        state.strokes = loaded;
                        render();
                        showToast("Loaded successfully");
                    }
                } catch (err) {
                    showToast("Error loading file");
                }
            };
            reader.readAsText(file);
            e.target.value = ''; // Reset input
        }

        function exportImage() {
            // Render to temp canvas to ensure BG is black (transparent canvas defaults to transparency in PNG)
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tCtx = tempCanvas.getContext('2d');
            tCtx.fillStyle = CONFIG.bgColor;
            tCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Draw all strokes on temp
            const originalCtx = ctx; 
            // We use the same render logic but redirect context is hard without refactoring drawStroke 
            // Easier: just composite current canvas over black rect
            tCtx.drawImage(canvas, 0, 0);

            const link = document.createElement('a');
            link.download = `blackboard-image-${new Date().toISOString().slice(0,10)}.png`;
            link.href = tempCanvas.toDataURL();
            link.click();
            showToast("Image exported");
        }

        function showToast(msg) {
            toastEl.innerText = msg;
            toastEl.style.opacity = '1';
            setTimeout(() => toastEl.style.opacity = '0', 2000);
        }

        // Start
        init();

    </script>
</body>
</html>
